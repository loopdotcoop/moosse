<!DOCTYPE HTML>
<html lang="en-GB">
<head>




<!-- META -->

<!-- Technical meta -->
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport"
   content="width=device-width, initial-scale=1.0, shrink-to-fit=no,
            maximum-scale=1.0, user-scalable=no">

<!-- Search engine meta -->
<title>Oompsh 0.2.4</title>
<meta name="description"
   content="A Node.js server which adds realtime push notification to Oom apps">
<link rel="author" href="README.md">




<!-- SCRIPT AND STYLE -->

<style>
body {
    font-family: Arial, sans-serif;
}
h2, nav {
    display: inline-block;
    margin: 0;
}
p {
    margin: 0;
}
input, pre, button, .samples a {
    width: 100%;
    padding: 0.5em 1em;
    box-sizing: border-box;
    border-radius: 0.5em;
    border: none;
    background: #ddd;
    font: 1em/0.65 monospace;
    text-decoration: none;
}
button, .samples a {
    color: #000;
    background: #ccc;
    border: 1px solid #fff;
    border-top: 2px solid #eee;
    border-bottom: 2px solid #bbb;
    cursor: pointer;
    transition: background-color 0.2s;
}
button {
    font-family: Arial, sans-serif;
}
.samples a {
    font-size: 0.8em;
}
button:hover, .samples a:hover {
    background: #ddd;
}
button:focus, .samples a:focus {
    background: #bbb;
}
button::-moz-focus-inner {
    border: 0; /* Firefox */
}
input, button, .samples a {
    outline: none!important;
}
input {
    width: 50%;
    background: #cde;
    border: 1px solid #fff;
    border-top: 2px solid #abc;
    border-bottom: 2px solid #def;
}
input::placeholder {
    color: #16a;
}
input.valid {
    background: #ced;
    border-top: 2px solid #acb;
    border-bottom: 2px solid #dfe;
}
input.invalid {
    background: #ecd;
    border-top: 2px solid #cab;
    border-bottom: 2px solid #fde;
}
input#apiv {
    width: 3.5em;
}
.samples {
    margin-bottom: 0.3em;
}
.samples button {
    width: 15em;
}
pre {
    margin-top: 0.3em;
    line-height: 2px;
}
pre div {
    padding: 0.2em;
    margin:0;
    line-height: 1em;
}
pre .client   { background: #eee }
pre .server   { background: #cde }
pre .client.error  { color: red }
pre .client.ok     { color: black }
pre .server.error  { color: red }
pre .server.ok     { color: #16a }
pre .message  { background: #ced }
pre .soft-end { background: #cff }
.table {
    display: table;
    width: 100%;
    margin-top: 2px;
}
.table >* {
    display: table-cell;
    width: 22.5%;
}
#admin-method,
#enduser-method {
    width: 10%;
}
#admin-body,
#enduser-body {
    width: 77.5%;
}
.hid {
    display: none;
}
</style>




</head>
<body>
<div class="container">




<!-- Header and Navigation menu -->
<h2>Oompsh 0.2.4</h2>
<nav> &nbsp;
  <a href="index.html" id="home-link">Home</a> &nbsp;
  <a href="support/test.html">Test @TODO</a> &nbsp;
  <a href="https://github.com/loopdotcoop/oompsh">Repo</a> &nbsp;
  <a href="https://www.npmjs.com/package/oompsh">NPM</a> &nbsp;&nbsp;
</nav>

<p>A Node.js server which adds realtime push notification to Oom apps</p>




<!-- Load the OOMPSH namespace, with configuration, API and validators -->
<script src="./oompsh-config.js"></script>




<!-- Add browser functions to the OOMPSH namespace -->

<script>!function(ROOT){
const OOMPSH = ROOT.OOMPSH


//// CLIENT UTILITIES

//// logClient()
//// logServer()
//// updateValidityHilite()
//// send()
//// begin()
//// end()


//// `logClient()` and `logServer()` both add a line to the onscreen logs.
//// `logClient()` is used to log activity happening in the browser.
//// `logServer()` is used to log messages from the server.
OOMPSH.logClient = function (data)      { log(this, data, 'client') }
OOMPSH.logServer = function (data, evt) { log(this, data, 'server', evt) }
function log ($log, raw, source, evt='') {

    //// Deal with `raw` if it’s a string - often an unparsed JSON string.
    if ('string' === typeof raw) // eg 'Hi', '99', '{"nope":0}' or '{"ok":"!"}'
        try {
            raw = JSON.parse(raw) // eg '99', '{"nope":0}' or '{"ok":"!"}'
        } catch (e) {
            raw = { ok:'(string data): ' + sanitize(raw) } } // eg 'Hi'

    //// Whatever has been passed to `raw`, convert it to a conformant plain
    //// object. That is, an object with either an 'ok' or an 'error' property.
    let data
    if ('object' !== typeof raw) // eg 'number' or 'boolean' (but not 'string')
        data = { ok:'(' + (typeof raw) + ' data): ' + sanitize(raw) }
    else // convert to a conformant object if not already, eg `{ok:'!'}`
        if (null != raw.ok || null != raw.error) // comformant, eg `{ok:'!'}`
            data = Object.assign({}, raw) // keep other properties
        else if (null == raw.ok && null != raw.message) // eg an error object
            data = Object.assign({ error:raw.message }, raw)
        else // some arbitrary object, eg `{nope:0}`
            data = { ok:'(object data): ' + sanitize( JSON.stringify(raw) ) }

    //// Add the log-line DIV to `$log.lines` and render the $log.
    const label = data.error ? 'error' : 'ok'
    const msg   = sanitize(data.error || data.ok)
    $log.lines.unshift(
        '<div class="' + label + ' ' + source + (evt?' '+evt:'') + '">'
      + ('    ' + ++$log.lineTally).slice(-4) // line number
      + ' ' + msg + '</div>' )
    $log.lines = $log.lines.slice(0,10)
    $log.innerHTML = ''
      // + 'Tries since modification: ' + triesSinceModification + '<br><br>\n'
      // + (null == numResults ? '' : 'Try ' + getTypes() + ' at ' + tryInfo() + '<br><br><br>\n')
      + $log.lines.join('\n')

}//log()


//// Makes arbitrary text suitable for writing to the log.
function sanitize (text) {
    text = ''+text
    if (80 < text.length) text = text.slice(0,80) + '...'
    text = text.replace(/</g, '&lt;')
    text = text.replace(/\n/g, '\\n')
    return text
}


//// Create admin sample buttons.
OOMPSH.addSampleButton = function (actions, method, config) {
    for (let action in actions) {
        const
            $sample = document.createElement('A')
          , tip     = actions[action].tip || ''
          , eg      = actions[action].eg  || ''
          , sample  = { method, action
              , filter: (eg.match(/([a-z0-9]+)$/)||[])[1] //@TODO better parser
              , body:   (eg.match(/BODY {(.+)}/)||[])[1]  //@TODO better parser
            }
        sample.filter = sample.filter === action ? '' : sample.filter
        sample.body = sample.body ? '{'+sample.body+'}' : ''
        $sample.innerHTML = '/' + action + (sample.filter?'/'+sample.filter:'')
        $sample.title = tip
        $sample.addEventListener('click', evt => {
            ['method','action','filter','body'].forEach( name => {
                const $el = config['$'+name]
                $el.value = sample[name] || ''
                document.cookie = $el.id + '=' + sample[name]
                OOMPSH.updateValidityHilite($el)
            })
            if (evt.altKey) setTimeout( () => OOMPSH.send(config), 1)
        })
        config.$samples.appendChild($sample)
    }
}//addSampleButton()


//// Changes an empty INPUT to blue, valid to green, or invalid to red.
//// Also, update wording of the ‘Begin * SSE Session’ button.
OOMPSH.updateValidityHilite = function ($el) {

    //// Get `usertype` and `name` from the INPUT’s ID.
    const
        parts = $el.id.split('-')
      , name = parts.pop() // eg 'filter' or 'apiv'
      , usertype = parts[0] // eg 'admin', 'enduser' (or undefined if apiv)
    if (usertype && ! /^admin$|^enduser$/.test(usertype) )
        throw Error(`usertype '${usertype}' invalid`)

    //// Set the INPUT’s class depending on its validity.
    $el.className = $el.value ? OOMPSH.valid[name].test($el.value.trim())
      ? 'valid' : 'invalid' : '' // green, red or blue

    //// Show a message after the '#domain' INPUT.
    if ('domain' === $el.id) {
        const $comment = document.querySelector('#domain-comment')
        if (! $el.value)
            $comment.innerHTML = ''
        else if (! OOMPSH.valid.domain.test($el.value) )
            $comment.innerHTML = 'Error: invalid domain'
        else if ( OOMPSH.valid.local.test($el.value) )
            $comment.innerHTML = 'https' === $el.value.slice(0,5)
              ? '(local SSL server)' : '(local servers don’t have to use https)'
        else
            $comment.innerHTML = 'https' === $el.value.slice(0,5)
              ? '(remote SSL server)' : 'Error: Remote servers must use https'
        $el.className = 'Error: ' === $comment.innerHTML.slice(0,7)
          ? 'invalid' : $el.value ? 'valid' : ''
    }

    //// Update wording of the ‘Begin * SSE Session’ button.
    if (usertype) {
        const
            $user  = document.querySelector('#'+usertype+'-user')
          , $pass  = document.querySelector('#'+usertype+'-pass')
          , $begin = document.querySelector('#'+usertype+'-begin')
        $begin.innerHTML = 'Begin '
          + ( $user.value.trim() || $pass.value.trim() ? 'Admin' : 'Enduser')
          + ' SSE Session'
    }

}//updateValidityHilite()


//// Sends a request to a URL and logs the result.
OOMPSH.send = function (config) {

    //// Use the `config` object to retrieve variables.
    const { $apiv, $domain, $method, $user, $pass, $action, $filter, $body, logClient, logServer } = config
    let apiv     =   $apiv.value.trim()
      , domain   = $domain.value.trim()
      , method   = $method.value.trim()
      , action   = $action.value.trim()
      , filter   = $filter.value.trim()
      , body     =   $body.value.trim() || null
      , bodyLog  = body ? sanitize(body) + ' to ' : ''
      , user     =   $user.value.trim()
      , pass     =   $pass.value.trim()
      , creds    = user||pass ? user + ':' + pass + '/' : ''
      , credsLog = user||pass ? user + ':' + '•'.repeat(pass.length) + '/' : ''
    domain += /\/$/.test(domain) ? '' : '/' // append a slash, if missing
    apiv   = apiv   ? apiv   + '/' : '' // append a slash if `apiv` has been set
    action = action ? action + '/' : filter ? '[action]/' : '' // don’t allow a blank ‘action’ if a ‘filter’ is specified
    filter = filter ? filter + '/' : '' // allow a blank ‘filter’

    //// Build the URL, eg 'http://localhost:1234/jo:pw/notify'.
    const url    = (domain + apiv + creds    + action + filter).slice(0,-1)
    const urlLog = (domain + apiv + credsLog + action + filter).slice(0,-1)

    const init = 'GET' === method
      ? {   method                     // *GET, POST, PUT, DELETE, etc.
          , cache:       'no-cache'    // *default, no-cache, reload, force-c...
          , mode:        'cors'        // *same-origin, no-cors, cors
          , redirect:    'error'       // *manual, follow, error
          , referrerPolicy:    'no-referrer' // *client, no-referrer
        }
      : {   method                     // *GET, POST, PUT, DELETE, etc.
          , cache:       'no-cache'    // *default, no-cache, reload, force-c...
          , mode:        'cors'        // *same-origin, no-cors, cors
          , redirect:    'error'       // *manual, follow, error
          , referrerPolicy:    'no-referrer' // *client, no-referrer
          , credentials: 'omit'        // *omit, include, same-origin @TODO omit?
          , body                       // must match 'Content-Type' header
          , headers: {
                'Content-Type':'application/json'
            }
        }

    //// Log that `send()` has been called. @TODO log invalidation errors too
    logClient({ok:`send() will ${method} ${bodyLog}${urlLog}`})

    //// Use the Fetch API to make the request.
    fetch(url, init)
       .then( res => res.text() ) // parse response to JSON
       .then( text => logServer(text) )
       .catch(text => logServer(text) )

}//send()


//// Starts an SSE (Server-Sent Events) connection.
OOMPSH.begin = function (config) {

    //// Use the `config` object to retrieve variables.
    const { $apiv, $domain, $user, $pass, $begin, $end, logClient, logServer, usertype } = config
    let apiv     =   $apiv.value.trim()
      , domain   = $domain.value.trim()
      , user     =   $user.value.trim()
      , pass     =   $pass.value.trim()
      , creds    = user||pass ? user + ':' + pass + '/' : ''
      , credsLog = user||pass ? user + ':' + '•'.repeat(pass.length) + '/' : ''
    domain += /\/$/.test(domain) ? '' : '/' // append a slash, if missing
    apiv = apiv ? apiv + '/' : '' // append a slash if `apiv` has been set

    //// Build the URL, eg 'http://localhost:1234/jo:pw/begin/enduser'
    const url         = domain + apiv + creds + 'begin/' + usertype
    const urlLog = domain + apiv + credsLog + 'begin/' + usertype

    //// Log that `begin()` has been called.
    if ('admin' !== usertype && 'enduser' !== usertype)
        return logClient({ error:'Can’t begin: `usertype` invalid' })
    if (config.es)
        return logClient({ error:'Can’t begin: EventSource already connected' })
    if (! window.EventSource)
        return logClient({ error:'Can’t begin: EventSource not supported' })
    logClient({ ok:`begin() will connect to ${urlLog}` })

    //// Update the buttons.
    $begin.className = 'hid'
    $end.className = ''

    const es = config.es = new EventSource(url)
    es.addEventListener('message', evt => {
        let data
        try { data = JSON.parse(evt.data)
        } catch (err) {
            return logClient({ error:'JSON: ' + err.message })
        }
        if (! data) throw Error('No data!') //@TODO handle better - maybe disconnect?
        logServer(data, 'message')
    }, false)

    es.addEventListener('open', evt =>
        logClient({ ok:'Connection was opened' }), false)

    es.addEventListener('error', evt => {
        evt = evt.originalTarget || evt // prefer the original error event
        if (EventSource.CONNECTING === evt.readyState)
            end(config, 'of an SSE error (readyState is CONNECTING)')
        else if (EventSource.OPEN === evt.readyState)
            end(config, 'of an SSE error (readyState is OPEN)')
        else if (EventSource.CLOSED === evt.readyState)
            end(config, 'of an SSE error (readyState is CLOSED)')
        else if (null != evt.readyState)
            logClient({ error:'Unexpected readyState ' + evt.readyState }) // should not be possible?
        else
            logClient({ error:'No evt.readyState: ' + JSON.stringify(evt) })
    }, false)

    //// Custom events.
    es.addEventListener('soft-end', evt => {
        let data
        try { data = JSON.parse(evt.data)
        } catch (err) {
            return logClient({ error:'JSON: ' + err.message })
        }
        if (! data) throw Error('No data!') //@TODO handle better - maybe disconnect?
        logServer(data, 'soft-end')
        end(config, "of 'soft-end' event")
    }, false)

}//begin()


//// Closes an SSE (Server-Sent Events) connection.
function end (config, reason="the ‘End’ button was clicked") {

    //// Log that `end()` has been called.
    config.logClient({ ok:'Closing SSE session because ' + reason })
    if (! config.es)
        return config.logClient({error:'Can’t end: EventSource not connected'})

    //// Close the connection and make `es` falsey.
    config.es.close()
    config.es = null

    //// Update the buttons.
    config.$begin.className = ''
    config.$end.className = 'hid'
}
OOMPSH.end = end


}(this)</script>




<!-- The API version and domain, used by the Admin Client and Enduser Client -->
<input id="apiv" placeholder="v?"></input>
<input id="domain" placeholder="domain"></input>
<span id="domain-comment"></span>




<!-- Admin Client -->
<hr>
<div id="admin-samples" class="samples">
  <button id="admin-begin">Begin Admin SSE Session</button>
  <button id="admin-end" class="hid">End SSE Session</button>
</div>
<div class="table">
  <input  id="admin-method" placeholder="method"></input><input
          id="admin-user"   placeholder="username"></input><input
          id="admin-pass"   placeholder="password"></input><input
          id="admin-action" placeholder="action"></input><input
          id="admin-filter" placeholder="filter"></input>
</div>
<div class="table">
  <input  id="admin-body"   placeholder="body"></input><button
          id="admin-send">Send</button>
</div>
<pre id="admin-log">Loading...</pre>
<script>!function(ROOT){
const OOMPSH = ROOT.OOMPSH

//// Initialise the admin config and EventSource object.
const config = {
    usertype: 'admin'
  , es: null
}

//// Add config’s references to the various admin input fields and buttons.
config.$apiv   = document.querySelector('#apiv')
config.$domain = document.querySelector('#domain')
'begin,end,samples,method,user,pass,action,filter,body,send,log'
   .split(',')
   .forEach(name => config['$'+name] = document.querySelector('#admin-'+name))
const { $send, $begin, $end, $samples, $log } = config

//// Set up admin logging.
config.logClient = OOMPSH.logClient.bind($log)
config.logServer = OOMPSH.logServer.bind($log)
$log.lineTally = 0
$log.lines = Array(10).fill('<div>&nbsp;</div>')

//// Log a ready message.
config.logClient({ ok:'Ready to send' })

//// Set up admin buttons.
$send.addEventListener( 'click', evt => OOMPSH.send(config) )
$begin.addEventListener( 'click', evt => OOMPSH.begin(config) )
$end.addEventListener( 'click', evt => OOMPSH.end(config) )

//// Create admin sample buttons.
OOMPSH.addSampleButton(OOMPSH.api.admin.GET, 'GET', config)
OOMPSH.addSampleButton(OOMPSH.api.admin.POST, 'POST', config)

}(this)</script>




<!-- Enduser Client -->
<hr>
<div id="enduser-samples" class="samples">
  <button id="enduser-begin">Begin Enduser SSE Session</button>
  <button id="enduser-end" class="hid">End SSE Session</button>
</div>
<div class="table">
  <input  id="enduser-method" placeholder="method"></input><input
          id="enduser-user"   placeholder="username"></input><input
          id="enduser-pass"   placeholder="password"></input><input
          id="enduser-action" placeholder="action"></input><input
          id="enduser-filter" placeholder="filter"></input>
</div>
<div class="table">
  <input  id="enduser-body"   placeholder="body"></input><button
          id="enduser-send">Send</button>
</div>
<pre id="enduser-log">Loading...</pre>
<script>!function(ROOT){
const OOMPSH = ROOT.OOMPSH


//// Initialise the enduser config and EventSource object.
const config = {
    usertype: 'enduser'
  , es: null
}

//// Add config’s references to the various admin input fields and buttons.
config.$apiv   = document.querySelector('#apiv')
config.$domain = document.querySelector('#domain')
'begin,end,samples,method,user,pass,action,filter,body,send,log'
   .split(',')
   .forEach(name => config['$'+name] = document.querySelector('#enduser-'+name))
const { $send, $begin, $end, $samples, $log } = config

//// Set up enduser logging.
config.logClient = OOMPSH.logClient.bind($log)
config.logServer = OOMPSH.logServer.bind($log)
$log.lineTally = 0
$log.lines = Array(10).fill('<div>&nbsp;</div>')

//// Log a ready message.
config.logClient({ ok:'Ready to connect' })

//// Set up enduser buttons.
$send.addEventListener( 'click', evt => OOMPSH.send(config) )
$begin.addEventListener( 'click', evt => OOMPSH.begin(config) )
$end.addEventListener( 'click', evt => OOMPSH.end(config) )

//// Create enduser sample buttons.
OOMPSH.addSampleButton(OOMPSH.api.enduser.GET, 'GET', config)
OOMPSH.addSampleButton(OOMPSH.api.enduser.POST, 'POST', config)

}(this)</script>




<!-- 1. Persist INPUT values after refresh (Firefox does this automatically) -->
<!-- 2. Highlight inputs blue, green or red depending on their validity -->
<!-- 3. Provide defaults for the API version and domain -->
<script>!function(ROOT){
    const $$inputs = document.querySelectorAll('input')

    //// Restore INPUT values to their previous values, if any.
    //// Also, highlight inputs blue, green or red depending on their validity.
    prevVals = {}
    document.cookie.split(';').forEach( keyval => {
        [ key, val ] = keyval.trim().split('=')
        prevVals[key] = val
    })
    $$inputs.forEach( $el => {
        $el.value = prevVals[$el.id] || ''
        OOMPSH.updateValidityHilite($el)
    })

    //// Update cookies and validity-highlight every time an input changes.
    $$inputs.forEach( $el => $el.addEventListener('input',
        evt => {
            document.cookie = $el.id + '=' + $el.value
            OOMPSH.updateValidityHilite($el)
        }
    ) )

    //// Provide defaults for the API version and domain.
    const
        $apiv         = document.querySelector('#apiv')
      , $domain       = document.querySelector('#domain')
      , matchDomainRx = /^https?:\/\/[-:.a-z0-9]+/
      , pgDomain      = ( location.href.match(matchDomainRx) || [])[0]
    $apiv.value   = $apiv.value || OOMPSH.configuration.APIV
    $domain.value = ROOT.OOMPSH.valid.domain.test($domain.value) ? $domain.value
      : (ROOT.OOMPSH.valid.local.test(pgDomain) ? pgDomain
      : ROOT.OOMPSH.configuration.remoteURL)
    OOMPSH.updateValidityHilite($apiv)
    OOMPSH.updateValidityHilite($domain)

}(this)</script>




</div><!--.container -->
</body>
</html>

<!DOCTYPE HTML>
<html lang="en-GB">
<head>




<!-- META -->

<!-- Technical meta -->
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport"
   content="width=device-width, initial-scale=1.0, shrink-to-fit=no,
            maximum-scale=1.0, user-scalable=no">

<!-- Search engine meta -->
<title>Oompsh 0.1.4</title>
<meta name="description"
   content="A Node.js server which adds realtime push notification to Oom apps">
<link rel="author" href="README.md">




<!-- SCRIPT AND STYLE -->

<style>
body {
    font-family: Arial, sans-serif;
}
h2, nav {
    display: inline-block;
    margin: 0;
}
p {
    margin: 0;
}
input, pre, button, .shortcuts a {
    width: 100%;
    padding: 0.5em 1em;
    box-sizing: border-box;
    border-radius: 0.5em;
    border: none;
    background: #ddd;
    font: 1em/0.65 monospace;
    text-decoration: none;
}
button, .shortcuts a {
    color: #000;
    background: #ccc;
    border: 1px solid #fff;
    border-top: 2px solid #eee;
    border-bottom: 2px solid #bbb;
    cursor: pointer;
    font-family: Arial, sans-serif;
    transition: background-color 0.2s;
}
.shortcuts a {
    font-size: 0.8em;
}
button:hover, .shortcuts a:hover {
    background: #ddd;
}
button:focus, .shortcuts a:focus {
    background: #bbb;
}
button::-moz-focus-inner {
    border: 0; /* Firefox */
}
input, button, .shortcuts a {
    outline: none!important;
}
input {
    width: 50%;
    background: #cde;
    border: 1px solid #fff;
    border-top: 2px solid #abc;
    border-bottom: 2px solid #def;
}
input::placeholder {
    color: #16a;
}
input.valid {
    background: #ced;
    border-top: 2px solid #acb;
    border-bottom: 2px solid #dfe;
}
input.invalid {
    background: #ecd;
    border-top: 2px solid #cab;
    border-bottom: 2px solid #fde;
}
input#apiv {
    width: 3.5em;
}
.shortcuts button {
    width: 18em;
}
pre {
    line-height: 2px;
}
pre div {
    padding: 0.2em;
    margin:0;
    line-height: 1em;
}
pre .client  { background: #eee }
pre .server  { background: #cde }
pre .client.error { color: red }
pre .client.ok    { color: black }
pre .server.error { color: red }
pre .server.ok    { color: #16a }
.table {
    display: table;
    width: 100%;
    margin-top: 2px;
}
.table >* {
    display: table-cell;
    width: 22.5%;
}
#admin-method,
#enduser-method {
    width: 10%;
}
#admin-body,
#enduser-body {
    width: 77.5%;
}
.hid {
    display: none;
}
</style>





</head>
<body>
<div class="container">




<!-- Header and Navigation menu -->
<h2>Oompsh 0.1.4</h2>
<nav> &nbsp;
  <a href="index.html" id="home-link">Home</a> &nbsp;
  <a href="support/test.html">Test @TODO</a> &nbsp;
  <a href="https://github.com/loopdotcoop/oompsh">Repo</a> &nbsp;
  <a href="https://www.npmjs.com/package/oompsh">NPM</a> &nbsp;&nbsp;
</nav>

<p>A Node.js server which adds realtime push notification to Oom apps</p>




<!-- Oompsh namespace, with utilities and API -->
<script>!function(ROOT){

//// Global API.
const OOMPSH = ROOT.OOMPSH = {
    VERSION: '0.1.4'
  , get APIV () { return 'v' + OOMPSH.VERSION.split('.')[0] }
  , logClient: function (data) { log(this, data, 'client') }
  , logServer: function (data) { log(this, data, 'server') }

    //// Validators.
  , valid: {
        local:  /^https?:\/\/(127\.0\.0\.1|localhost)/
      , domain: /^https?:\/\/[-:.a-z0-9]+\/?$/
    }

    //// Methods more complex than a one-liner are defined below:
  , send
  , connect
  , disconnect
  , updateValidityHilite

  , api: {
        admin: {
            GET:  [ 'version' ]
          , POST: [ 'disconnect', 'hard-disconnect', 'notify' ]
        }
      , enduser: {
            GET:  [ 'version', 'browse', 'read' ]
          , POST: [ 'edit', 'add', 'delete', 'notify' ]
        }
    }

}//OOMPSH


//// Updates the log.
function log ($log, raw, source) {

    //// Deal with `raw` if it’s a string - often an unparsed JSON string.
    if ('string' === typeof raw) // eg 'Hi', '99', '{"nope":0}' or '{"ok":"!"}'
        try {
            raw = JSON.parse(raw) // eg '99', '{"nope":0}' or '{"ok":"!"}'
        } catch (e) {
            raw = { ok:'(string data): ' + sanitize(raw) } } // eg 'Hi'

    //// Whatever has been passed to `raw`, convert it to a conformant plain
    //// object. That is, an object with either an 'ok' or an 'error' property.
    let data
    if ('object' !== typeof raw) // eg 'number' or 'boolean' (but not 'string')
        data = { ok:'(' + (typeof raw) + ' data): ' + sanitize(raw) }
    else // convert to a conformant object if not already, eg `{ok:'!'}`
        if (null != raw.ok || null != raw.error) // comformant, eg `{ok:'!'}`
            data = Object.assign({}, raw) // keep other properties
        else if (null == raw.ok && null != raw.message) // eg an error object
            data = Object.assign({ error:raw.message }, raw)
        else // some arbitrary object, eg `{nope:0}`
            data = { ok:'(object data): ' + sanitize( JSON.stringify(raw) ) }

    //// Add the log-line DIV to `$log.lines` and render the $log.
    const label = data.error ? 'error' : 'ok'
    const msg   = sanitize(data.error || data.ok)
    $log.lines.unshift(
        '<div class="' + label + ' ' + source + '">'
      + ('    ' + ++$log.lineTally).slice(-4) // line number
      + ' ' + msg + '</div>' )
    $log.lines = $log.lines.slice(0,10)
    $log.innerHTML = ''
      // + 'Tries since modification: ' + triesSinceModification + '<br><br>\n'
      // + (null == numResults ? '' : 'Try ' + getTypes() + ' at ' + tryInfo() + '<br><br><br>\n')
      + $log.lines.join('\n')

}//log()


//// Makes arbitrary text suitable for writing to the log.
function sanitize (text) {
    text = ''+text
    if (80 < text.length) text = text.slice(0,80) + '...'
    text = text.replace(/</g, '&lt;')
    text = text.replace(/\n/g, '\\n')
    return text
}


//// Changes an empty INPUT to blue, valid to green, or invalid to red.
function updateValidityHilite ($el) {

    //// Get `usertype` and `name` from the INPUT’s ID.
    const
        parts = $el.id.split('-')
      , name = parts.pop() // eg 'target' or 'apiv'
      , usertype = parts[0] // eg 'admin', 'enduser' (or undefined if apiv)
    if (usertype && ! /^admin$|^enduser$/.test(usertype) )
        throw Error(`usertype '${usertype}' invalid`)

    //// Define regular expressions for validating the INPUT’s value.
    const
        first = '[a-zA-Z0-9!()_`~@\'"^]' // not allowed to start with . or -
      , other = '[a-zA-Z0-9!()_`~@\'"^.-]'
      , rx = {
            apiv:   /^v\d+$/
          , domain: /^https?:\/\/[-:.a-z0-9]+\/?$/
          , method: /^(GET|POST)$/
          , user:   new RegExp(`^(${first}${other}{0,64})$`)
          , pass:   new RegExp(`^(${first}${other}{0,64})$`)
          , action: ! usertype ? null : new RegExp( `^(`
              + OOMPSH.api[usertype ].GET.join('|') + '|'
              + OOMPSH.api[usertype].POST.join('|') + `)$` )
          , target: /^.+$/ //@TODO
          , body:   /^.+$/ //@TODO
        }

    //// Set the INPUT’s class depending on its validity.
    $el.className = rx[name].test( $el.value.trim() ) ? 'valid' // green
      : $el.value ? 'invalid' : '' // red or blue

    //// Show a message after the '#domain' INPUT.
    if ('domain' !== $el.id) return
    const $comment = document.querySelector('#domain-comment')
    if (! $el.value)
        $comment.innerHTML = ''
    else if (! rx.domain.test($el.value) )
        $comment.innerHTML = 'Error: invalid domain'
    else if ( OOMPSH.valid.local.test($el.value) )
        $comment.innerHTML = 'https' === $el.value.slice(0,5)
          ? '(local SSL server)' : '(local servers don’t have to use https)'
    else
        $comment.innerHTML = 'https' === $el.value.slice(0,5)
          ? '(remote SSL server)' : 'Error: Remote servers must use https'
    $el.className = 'Error: ' === $comment.innerHTML.slice(0,7)
      ? 'invalid' : $el.value ? 'valid' : ''

}


//// Sends a request to a URL and logs the result.
function send (config) {

    //// Use the `config` object to retrieve variables.
    const { $apiv, $domain, $method, $user, $pass, $action, $target, $body, logClient, logServer } = config
    let apiv     =   $apiv.value.trim()
      , domain   = $domain.value.trim()
      , method   = $method.value.trim()
      , action   = $action.value.trim()
      , target   = $target.value.trim()
      , body     =   $body.value.trim() || null
      , bodyLog  = body ? sanitize(body) + ' to ' : ''
      , user     =   $user.value.trim()
      , pass     =   $pass.value.trim()
      , creds    = user||pass ? user + ':' + pass + '/' : ''
      , credsLog = user||pass ? user + ':' + '•'.repeat(pass.length) + '/' : ''
    domain += /\/$/.test(domain) ? '' : '/' // append a slash, if missing
    apiv   = apiv   ? apiv   + '/' : '' // append a slash if `apiv` has been set
    action = action ? action + '/' : target ? '[action]/' : '' // don’t allow a blank ‘action’ if a ‘target’ is specified
    target = target ? target + '/' : '' // allow a blank ‘target’

    //// Build the URL, eg 'http://localhost:1234/jo:pw/notify'.
    const url    = (domain + apiv + creds    + action + target).slice(0,-1)
    const urlLog = (domain + apiv + credsLog + action + target).slice(0,-1)

    const init = 'GET' === method
      ? {   method                     // *GET, POST, PUT, DELETE, etc.
          , cache:       'no-cache'    // *default, no-cache, reload, force-c...
          , mode:        'cors'        // *same-origin, no-cors, cors
          , redirect:    'error'       // *manual, follow, error
          , referrerPolicy:    'no-referrer' // *client, no-referrer
        }
      : {   method                     // *GET, POST, PUT, DELETE, etc.
          , cache:       'no-cache'    // *default, no-cache, reload, force-c...
          , mode:        'cors'        // *same-origin, no-cors, cors
          , redirect:    'error'       // *manual, follow, error
          , referrerPolicy:    'no-referrer' // *client, no-referrer
          , credentials: 'omit'        // *omit, include, same-origin @TODO omit?
          , body                       // must match 'Content-Type' header
          , headers: {
                'Content-Type':'application/json'
            }
        }
    //// Log that `send()` has been called. @TODO log invalidation errors too
    logClient({ok:`send() will ${method} ${bodyLog}${urlLog}`})

    //// Use the Fetch API to make the request.
    fetch(url, init)
       .then( res => res.text() ) // parse response to JSON
       .then( text => logServer(text) )
       .catch(text => logServer(text) )

}//send()


//// Makes an SSE (Server-Sent Events) connection.
function connect (config) {

    //// Use the `config` object to retrieve variables.
    const { $apiv, $domain, $user, $pass, $connect, $disconnect, logClient, logServer, usertype } = config
    let apiv     =   $apiv.value.trim()
      , domain   = $domain.value.trim()
      , user     =   $user.value.trim()
      , pass     =   $pass.value.trim()
      , creds    = user||pass ? user + ':' + pass + '/' : ''
      , credsLog = user||pass ? user + ':' + '•'.repeat(pass.length) + '/' : ''
    domain += /\/$/.test(domain) ? '' : '/' // append a slash, if missing
    apiv = apiv ? apiv + '/' : '' // append a slash if `apiv` has been set

    //// Build the URL, eg 'http://localhost:1234/jo:pw/connect/enduser'
    const url         = domain + apiv + creds + 'connect/' + usertype
    const urlLog = domain + apiv + credsLog + 'connect/' + usertype

    //// Log that `connect()` has been called.
    if ('admin' !== usertype && 'enduser' !== usertype)
        return logClient({ error:'Can’t connect: `usertype` invalid' })
    if (config.es)
        return logClient({ error:'Can’t connect: EventSource already connected' })
    if (! window.EventSource)
        return logClient({ error:'Can’t connect: EventSource not supported' })
    logClient({ ok:`connect() will connect to ${urlLog}` })

    //// Update the buttons.
    $connect.className = 'hid'
    $disconnect.className = ''

    const es = config.es = new EventSource(url)
    es.addEventListener('message', evt => {
        let data
        try { data = JSON.parse(evt.data)
        } catch (err) {
            return logClient({ error:'JSON: ' + err.message })
        }
        if (! data) throw Error('No data!') //@TODO handle better - maybe disconnect?
        logServer(data)
    }, false)

    es.addEventListener('open', evt =>
        logClient({ ok:'Connection was opened' }), false)

    es.addEventListener('error', evt => {
        evt = evt.originalTarget || evt // prefer the original error event
        if (EventSource.CONNECTING === evt.readyState)
            disconnect(config, 'of an SSE error (readyState is CONNECTING)')
        else if (EventSource.OPEN === evt.readyState)
            disconnect(config, 'of an SSE error (readyState is OPEN)')
        else if (EventSource.CLOSED === evt.readyState)
            disconnect(config, 'of an SSE error (readyState is CLOSED)')
        else if (null != evt.readyState)
            logClient({ error:'Unexpected readyState ' + evt.readyState }) // should not be possible?
        else
            logClient({ error:'No evt.readyState: ' + JSON.stringify(evt) })
    }, false)

    //// Custom events.
    es.addEventListener('disconnect', evt =>
        disconnect(config, 'server told me to'), false)

}//connect()


//// Closes an SSE (Server-Sent Events) connection.
function disconnect (config, reason="the ‘Disconnect’ button was clicked") {

    //// Log that `disconnect()` has been called.
    config.logClient({ ok:'disconnecting because ' + reason })
    if (! config.es)
        return config.logClient({ error:'Can’t disconnect: EventSource is not connected' })

    //// Close the connection and make `es` falsey.
    config.es.close()
    config.es = null

    //// Update the buttons.
    config.$connect.className = ''
    config.$disconnect.className = 'hid'
}


}(this)</script>




<!-- The API version and domain, used by the Admin Client and Enduser Client -->
<input id="apiv" placeholder="v?"></input>
<input id="domain" placeholder="domain"></input>
<span id="domain-comment"></span>




<!-- Admin Client -->
<hr>
<div id="admin-shortcuts" class="shortcuts">
  <button id="admin-connect">Connect Admin Client</button>
  <button id="admin-disconnect" class="hid">Disconnect Admin Client</button>
  <a data-method=""     data-action=""           data-target=""    data-body="">Clear</a>
  <a data-method="GET"  data-action="version"    data-target=""    data-body="">Version</a>
  <a data-method="POST" data-action="disconnect" data-target="all" data-body="">Disconnect All</a>
  <a data-method="POST" data-action="notify"     data-target="all" data-body='{"message":"Hello Ooms"}'>Hello Ooms</a>
</div>
<div class="table">
  <input  id="admin-method" placeholder="method"></input><input
          id="admin-user"   placeholder="username"></input><input
          id="admin-pass"   placeholder="password"></input><input
          id="admin-action" placeholder="action"></input><input
          id="admin-target" placeholder="target"></input>
</div>
<div class="table">
  <input  id="admin-body"   placeholder="body"></input><button
          id="admin-send">Send</button>
</div>
<pre id="admin-log">Loading...</pre>
<script>!function(ROOT){
const OOMPSH = ROOT.OOMPSH

//// Initialise the admin config and EventSource object.
const config = {
    usertype: 'admin'
  , es: null
}

//// Add config’s references to the various admin input fields and buttons.
config.$apiv   = document.querySelector('#apiv')
config.$domain = document.querySelector('#domain')
'connect,disconnect,shortcuts,method,user,pass,action,target,body,send,log'
   .split(',')
   .forEach( name => {
        const $el = config['$'+name] = document.querySelector('#admin-'+name)
    })
const { $send, $connect, $disconnect, $shortcuts, $log } = config

//// Set up admin logging.
config.logClient = OOMPSH.logClient.bind($log)
config.logServer = OOMPSH.logServer.bind($log)
$log.lineTally = 0
$log.lines = Array(10).fill('<div>&nbsp;</div>')

//// Log a ready message.
config.logClient({ ok:'Ready to send' })

//// Set up admin buttons.
$send.addEventListener( 'click', evt => OOMPSH.send(config) )
$connect.addEventListener( 'click', evt => OOMPSH.connect(config) )
$disconnect.addEventListener( 'click', evt => OOMPSH.disconnect(config) )

//// Set up admin shortcuts.
$shortcuts.querySelectorAll('a').forEach( $shortcut => {
    $shortcut.href = 'javascript:void(0)'
    $shortcut.addEventListener('click', function (evt) {
        ['method','action','target','body'].forEach( name => {
            const $el = config['$'+name]
            $el.value = this.getAttribute('data-'+name)
            document.cookie = $el.id + '=' + $el.value
            OOMPSH.updateValidityHilite($el)
        })
    })
})

}(this)</script>




<!-- Enduser Client -->
<hr>
<div id="enduser-shortcuts" class="shortcuts">
  <button id="enduser-connect">Connect Enduser Client</button>
  <button id="enduser-disconnect" class="hid">Disconnect Enduser Client</button>
  <a data-method=""     data-action=""           data-target=""    data-body="">Clear</a>
  <a data-method="GET"  data-action="version"    data-target=""    data-body="">Version</a>
  <a data-method="POST" data-action="edit"       data-target="1"   data-body="">Edit wpid 1</a>
  <a data-method="POST" data-action="notify"     data-target="all" data-body='{"message":"Hello Ooms"}'>Hello Ooms</a>
</div>
<div class="table">
  <input  id="enduser-method" placeholder="method"></input><input
          id="enduser-user"   placeholder="username"></input><input
          id="enduser-pass"   placeholder="password"></input><input
          id="enduser-action" placeholder="action"></input><input
          id="enduser-target" placeholder="target"></input>
</div>
<div class="table">
  <input  id="enduser-body"   placeholder="body"></input><button
          id="enduser-send">Send</button>
</div>
<pre id="enduser-log">Loading...</pre>
<script>!function(ROOT){
const OOMPSH = ROOT.OOMPSH


//// Initialise the enduser config and EventSource object.
const config = {
    usertype: 'enduser'
  , es: null
}

//// Add config’s references to the various admin input fields and buttons.
config.$apiv   = document.querySelector('#apiv')
config.$domain = document.querySelector('#domain')
'connect,disconnect,shortcuts,method,user,pass,action,target,body,send,log'
   .split(',')
   .forEach( name => {
        const $el = config['$'+name] = document.querySelector('#enduser-'+name)
    })
const { $send, $connect, $disconnect, $shortcuts, $log } = config

//// Set up enduser logging.
config.logClient = OOMPSH.logClient.bind($log)
config.logServer = OOMPSH.logServer.bind($log)
$log.lineTally = 0
$log.lines = Array(10).fill('<div>&nbsp;</div>')

//// Log a ready message.
config.logClient({ ok:'Ready to connect' })

//// Set up enduser buttons.
$send.addEventListener( 'click', evt => OOMPSH.send(config) )
$connect.addEventListener( 'click', evt => OOMPSH.connect(config) )
$disconnect.addEventListener( 'click', evt => OOMPSH.disconnect(config) )

//// Set up enduser shortcuts.
$shortcuts.querySelectorAll('a').forEach( $shortcut => {
    $shortcut.href = 'javascript:void(0)'
    $shortcut.addEventListener('click', function (evt) {
        ['method','action','target','body'].forEach( name => {
            const $el = config['$'+name]
            $el.value = this.getAttribute('data-'+name)
            document.cookie = $el.id + '=' + $el.value
            OOMPSH.updateValidityHilite($el)
        })
    })
})
}(this)</script>




<!-- 1. Persist INPUT values after refresh (Firefox does this automatically) -->
<!-- 2. Highlight inputs blue, green or red depending on their validity -->
<!-- 3. Provide defaults for the API version and domain -->
<script>!function(ROOT){
    const $$inputs = document.querySelectorAll('input')

    //// Restore INPUT values to their previous values, if any.
    //// Also, highlight inputs blue, green or red depending on their validity.
    prevVals = {}
    document.cookie.split(';').forEach( keyval => {
        [ key, val ] = keyval.trim().split('=')
        prevVals[key] = val
    })
    $$inputs.forEach( $el => {
        $el.value = prevVals[$el.id] || ''
        OOMPSH.updateValidityHilite($el)
    })

    //// Update cookies and validity-highlight every time an input changes.
    $$inputs.forEach( $el => $el.addEventListener('input',
        evt => {
            document.cookie = $el.id + '=' + $el.value
            OOMPSH.updateValidityHilite($el)
        }
    ) )

    ////
    const
        remoteURL     = 'https://oompsh.herokuapp.com'
      , $apiv         = document.querySelector('#apiv')
      , $domain       = document.querySelector('#domain')
      , matchDomainRx = /^https?:\/\/[-:.a-z0-9]+/
      , pgDomain      = ( location.href.match(matchDomainRx) || [])[0]
    $apiv.value   = $apiv.value || OOMPSH.APIV
    $domain.value = ROOT.OOMPSH.valid.domain.test($domain.value) ? $domain.value
      : (ROOT.OOMPSH.valid.local.test(pgDomain) ? pgDomain : remoteURL)
    OOMPSH.updateValidityHilite($apiv)
    OOMPSH.updateValidityHilite($domain)

}(this)</script>




</div><!--.container -->
</body>
</html>
